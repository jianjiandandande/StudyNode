---
title:目标检测相关
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---
# 目标检测

## 定义
 目标检测是在图片中对**可变数量**的目标进行查找和分类
 
 ## 难点
 
* 目标种类与数量问题

* 目标尺度问题

* 存在环境干扰问题

## 目标检测方法的变迁

### 传统的目标检测方法
原理：基于传统的手工特征和滑动窗口的方式来进行目标检测和定位

* Viola-Jones算法,采用积分图特征，结合Adboost分类器，用于人脸检测
	* Haar特征提取(纹理特征的一种)
		* 特征就是像素点的计算结果
		* base core all三种共14个候选框
		* 白区域的像素值之和-黑区域的像素值之和
	* 训练人脸分类器(Adboost算法)
		* 结构：多个级联的强分类器，一个强分类器对应多个级联的弱分类器，一个弱分类器对应多个弱特征结点
		* 强分类器的作用：判决(通过特征与阈值的比较来进行分类判决，其中若有多个强分类器，那个这些强分类器的阈值判决都必须符合判决条件才能进行正确分类) x1>t1 and x2>t2 and x3>t3
		* 弱分类器的作用：计算强分类器中的特征 x2 = sum(y1,y2,y3) y1，y2,y3为弱分类器的特征
		* opencv中一个弱分类器由3个haar特征组成，一个haar特征对应一个弱特征结点
		* 弱特征结点的计算 
			 1.node1  haar1 > nodeT1  z1 = a1
			 2.node1  haar1 < nodeT1  z1 = a2
		* 弱分类器的特征：
			 1.Z = sum(z1+z2+z3)>T y1 = AA
			 2.Z = sum(z1+z2+z3)<T y1 = BB
		* adboost的训练过程
			* 初始化权值分布(需要通过某种计算公式进行计算，初始化时的权值应相同)eg:苹果（ 0.1）  苹果（ 0.1）  苹果（ 0.1）  香蕉（ 0.1）
			* 遍历阈值  得到误差概率p  其中minP = t
			* 权重系数的计算
			* 更新训练数据的权重分布(0.2  0.2  0.2  0.8)
			* 训练终止条件: for count  ;  p(概率的阈值)
	* 滑动窗口(候选框)
* HOG+SVM用于行人检测
	* SVM
		* 本质：寻求一个最优的超平面进行分类
		* 核：line
	* HOG
		* 特征的计算：
			* 模块划分 image>win>block>cell
				* image
				* win窗口 特征计算最顶层的单元(obj) -->step  win size = 64 * 128
				* block块  -->step(如何在win中滑动)  win窗口的大小是block大小的整数倍 block size = 16* 16
				* cell(不可滑动)  -->bin  size = 8 * 8
			* 根据HOG特征模板计算梯度和方向  模板
				* 梯度计算的是每个像素的梯度，包含大小和方向，而方向一般是0-360，如果按照N度进行划分，那么360/N即为bin
				* HOG特征的维度：可以描述一个obj的所有信息，所以`维度=（win中block的个数）* 一个block中cell的个数 * 一个cell中bin的个数`
				* HOG特征是一个win中所有像素的梯度共同构成
				* 像素梯度的计算，也是有模板的，其中水平方向：[1 0 -1]，竖直方向：[[1]  [0]  [-1]]
					* 水平方向 a = p1 * 1 + p2 * 0 + p3 * (-1)
					* 竖直方向 b = p1 * 1 + p2 * 0 + p3 * (-1)
					* 角度 = arctan(a/b)
			* bin投影 -- 一般cell中需要包含完整的信息，所以一个cell中必须包含360/N个bin
			* 计算每个模块的特征
* DPM，基于HOG特征的一种变种

问题：特征难以设计，同时设计的特征会存在各种各样的问题，比如对一些特定的环境可能会不适应，或者设计的特征往往会不鲁棒，效率也会存在一定的瓶颈，使用滑动窗口对目标进行定位，并判定的过程会比较耗时

### 基于深度学习的检测算法时期

* Faster RCNN

* SSD

* Yolo

![传统目标检测方法与深度学习目标检测算法的对比](./images/1568634952255.png)

![传统目标检测方法基本流程](./images/1568635248751.png)